# 퀴즈 대기방 새로고침 문제 해결 방안

## 문제 요약

방장이 퀴즈 대기방에서 새로고침을 하면:
1. 윈도우 `alert`로 "이미 시작된 방" 메시지 표시
2. 메인 페이지로 이동 후 다른 방 입장 시 "이미 다른 탭에서 게임 참여 중" 오류
3. 메인 페이지에서 새로고침 후에야 정상 입장 가능

일반 참가자는 새로고침 시 문제없이 재참가 가능.

---

## 근본 원인 분석 (백엔드 코드 검증 완료)

### 백엔드 세션 정리 로직 확인

백엔드 코드를 확인한 결과, **세션 정리는 정상적으로 작동**하고 있습니다:

```java
// WebSocketSessionService.java - handleSessionDisconnect()
public boolean handleSessionDisconnect(Long userId, String sessionId) {
    try {
        // 1. 활성 세션 검증
        if (!isActiveSession(userId, sessionId)) {
            return false;
        }
        // 2. 방 퇴장 처리
        handleRoomLeave(userId);
        return true;
    } finally {
        // 3. 세션 정리 (예외 발생 여부와 무관하게 항상 실행)
        cleanupSession(userId, sessionId);
    }
}
```

**방장 퇴장 시 처리:**
```java
// GameRoomLeaveService.java - handleHostLeave()
private ParticipantEventResponse handleHostLeave(GameRoom room, ParticipantResponse hostResponse) {
    // 1. 방장 제외한 다른 참가자들의 userId 목록 조회
    // 2. 남은 모든 참가자를 Bulk Delete로 삭제
    // 3. 방 종료 처리 (상태 변경)
    // 4. 남은 참가자들의 세션 정리
    sessionService.cleanupMultipleSessions(otherParticipantUserIds, roomId);
    // 5. 방 종료 이벤트 반환
}
```

### 실제 문제의 원인

백엔드는 정상 작동하므로, 문제는 **프론트엔드의 타이밍과 상태 관리**에 있습니다:

#### 방장 새로고침 시 발생하는 일 (정확한 시퀀스)

```
방장 새로고침 (F5)
    ↓
[타이밍 1] 브라우저: 페이지 언로드 시작
    ↓
[타이밍 2] WebSocket 연결 강제 종료 (브라우저)
    ↓
[타이밍 3] 백엔드: DISCONNECT 이벤트 수신
    ├─ 방장 퇴장 감지
    ├─ 방 종료 처리 (DB 업데이트)
    ├─ 다른 참가자들에게 ROOM_CLOSED 브로드캐스트
    └─ 세션 정리 (userSessionRegistry.unbind())
    ↓
[타이밍 4] 브라우저: 페이지 리로드 완료
    ↓
[타이밍 5] 프론트엔드: useWaitingRoomWebSocket 훅 실행
    ├─ WebSocket 재연결 시도
    └─ ROOM_JOIN 메시지 전송
    ↓
[타이밍 6] 백엔드: ROOM_JOIN 처리
    ├─ 방 조회 → 방이 FINISHED 상태
    └─ "ROOM_ALREADY_STARTED" 에러 반환
    ↓
[타이밍 7] 프론트엔드: handleError 실행
    ├─ 윈도우 alert 표시 ← 문제 1: UI 일관성
    └─ navigate('/main') 실행
    ↓
[타이밍 8] 메인 페이지 로드
    ├─ 하지만 WebSocket 연결은 아직 살아있음 ← 문제 2: 연결 정리 안됨
    └─ 백엔드 세션은 이미 정리됨 (타이밍 3에서)
    ↓
[타이밍 9] 사용자가 다른 방 입장 시도
    ├─ RoomService.checkWsSession() 호출
    ├─ 프론트엔드: websocketService.isConnected() = true ← 문제!
    └─ 백엔드: 세션 없음 (이미 정리됨)
    ↓
결과: 프론트엔드와 백엔드의 세션 상태 불일치
```

#### 핵심 문제점

**문제 A: 프론트엔드 WebSocket 연결이 정리되지 않음**
- 새로고침 후 에러 발생 시 `navigate('/main')`만 호출
- `websocketService.disconnect()`가 호출되지 않음
- 프론트엔드는 여전히 연결되어 있다고 판단

**문제 B: 세션 체크 로직의 불일치**
```javascript
// RealTimeQuizSidebar.jsx - handleRoomClick()
const sessionStatus = await RoomService.checkWsSession();
if (sessionStatus.active) {
  // 차단됨
}
```

이 체크는 **백엔드 세션**을 확인하는데, 백엔드는 이미 세션을 정리했습니다.
하지만 **프론트엔드 WebSocket 연결**은 여전히 살아있어서,
다음 방 입장 시도 시 새로운 연결을 만들려고 하면 충돌이 발생합니다.

**문제 C: UI 일관성**
- 일반 참가자: `AlertModal` 컴포넌트 사용
- 방장 에러: 윈도우 기본 `alert` 사용

---

## 해결 방안

### 방안 1: 프론트엔드 WebSocket 연결 정리 (권장, 가장 간단)

**핵심 아이디어:**
- 백엔드 세션은 이미 정상적으로 정리되고 있음
- 문제는 프론트엔드 WebSocket 연결이 정리되지 않는 것
- 에러 발생 시 메인으로 이동하기 전에 WebSocket 연결을 명시적으로 끊어야 함

**장점:**
- 가장 빠른 구현 (프론트엔드만 수정)
- 백엔드 변경 불필요
- 근본 원인 직접 해결

**구현 단계:**

#### Step 1: handleError에서 WebSocket 연결 정리 추가

`QuizWaitingRoom.jsx`의 `handleError` 함수 수정:

```javascript
const handleError = useCallback((data) => {
  console.error('📥 에러:', data);

  if (data.error === 'ROOM_ALREADY_STARTED' || 
      (data.message && data.message.includes('이미 시작된 방'))) {
    if (wsHooks.isNavigatingToGameRef.current) {
      console.log('⏭️ 게임 페이지로 이동 중이므로 에러 무시');
      return;
    }
    
    console.warn('⚠️ 방장이 나가서 방이 종료되었습니다.');
    
    // ✅ 핵심 수정: WebSocket 연결 정리
    websocketService.disconnect();
    console.log('✅ WebSocket 연결 해제 완료');
    
    // ✅ 웹캠 정리
    if (isWebcamOn) {
      stopWebcam();
      console.log('✅ 웹캠 정리 완료');
    }
    
    // ✅ AlertModal로 변경 (UI 일관성)
    setShowRoomClosedAlert(true);
    return;
  }

  // 기타 에러는 기존대로 alert 사용
  alert(data.message || data.detail || '오류가 발생했습니다.');
}, [navigate, setShowRoomClosedAlert, isWebcamOn, stopWebcam]);
```

#### Step 2: handleRoomClosedAlertClose 수정

AlertModal 닫을 때 메인으로 이동:

```javascript
const handleRoomClosedAlertClose = useCallback(() => {
  // WebSocket과 웹캠은 이미 handleError에서 정리됨
  // 여기서는 페이지 이동만 수행
  navigate('/main');
}, [navigate]);
```

**이 방법으로 해결되는 이유:**
1. 방장 새로고침 → WebSocket 끊김 → 백엔드 세션 정리 (정상)
2. 페이지 리로드 → 방 재입장 시도 → 에러 발생
3. **handleError에서 WebSocket 명시적으로 끊음** ← 핵심!
4. AlertModal 표시 → 확인 클릭 → 메인으로 이동
5. 다른 방 입장 시도 → WebSocket 연결 없음 → 정상 입장

---

### 방안 2: useWaitingRoomWebSocket 훅 개선 (더 안전)

**핵심 아이디어:**
- 에러 발생 시 자동으로 WebSocket 정리
- 컴포넌트 언마운트 시에도 확실하게 정리

**장점:**
- 더 안전한 정리 보장
- 다른 에러 상황에도 대응 가능
- 메모리 누수 방지

**구현:**

```javascript
// useWaitingRoomWebSocket.js

useEffect(() => {
  // ... 기존 코드 ...

  const handleError = (data) => {
    console.error('📥 에러:', data);
    
    // 에러 발생 시 WebSocket 정리
    if (data.error === 'ROOM_ALREADY_STARTED' || 
        data.error === 'ROOM_NOT_FOUND' ||
        data.error === 'UNAUTHORIZED') {
      console.log('🔌 에러로 인한 WebSocket 연결 해제');
      websocketService.disconnect();
    }
    
    // 상위 컴포넌트의 에러 핸들러 호출
    if (onError) {
      onError(data);
    }
  };

  // ... 이벤트 리스너 등록 ...

  // cleanup: 컴포넌트 언마운트 시 확실하게 정리
  return () => {
    if (!isNavigatingToGameRef.current) {
      console.log('🧹 useWaitingRoomWebSocket cleanup');
      websocketService.disconnect();
    }
  };
}, [roomId, myUserId, isAuthenticated]);
```

---

### 방안 3: 세션 체크 로직 개선 (선택적)

**문제:**
- `RealTimeQuizSidebar`에서 세션 체크 시 백엔드만 확인
- 프론트엔드 WebSocket 연결 상태는 확인하지 않음

**개선:**

```javascript
// RealTimeQuizSidebar.jsx - handleRoomClick()

const handleRoomClick = async (roomId) => {
  // ... 기존 검증 로직 ...

  // ✅ 개선: 프론트엔드 WebSocket 연결 상태도 확인
  if (websocketService.isConnected()) {
    // 연결이 있으면 먼저 끊기
    console.log('🔌 기존 WebSocket 연결 정리');
    websocketService.disconnect();
    
    // 약간의 대기 시간
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  // 백엔드 세션 체크
  try {
    const sessionStatus = await RoomService.checkWsSession();

    if (sessionStatus.active) {
      showAlert(
        '입장 불가',
        '이미 다른 탭에서 게임에 참여 중입니다. 기존 탭을 종료해주세요.',
        'warning'
      );
      return;
    }

    // 모든 조건 통과 → 입장 허용
    navigate(`/quiz/waiting/${roomId}`);
    onClose();
  } catch (err) {
    // ... 에러 처리 ...
  }
};
```

---

### 최종 권장 방안: 방안 1 + 방안 2 조합

**Phase 1: 긴급 수정 (방안 1)**
1. `handleError`에서 WebSocket 연결 정리 추가
2. AlertModal로 UI 통일
3. 즉시 배포 가능

**Phase 2: 안정화 (방안 2)**
1. `useWaitingRoomWebSocket` 훅 개선
2. cleanup 로직 강화
3. 다음 배포에 포함

---

## 구현 우선순위

### Phase 1: 긴급 수정 (1일)
1. ✅ `QuizWaitingRoom.jsx`의 `handleError` 함수 수정
  - WebSocket 연결 정리 추가
  - 웹캠 정리 추가
  - AlertModal로 변경
2. ✅ `handleRoomClosedAlertClose` 함수 수정
  - 페이지 이동만 수행

### Phase 2: 안정화 (2-3일)
1. ✅ `useWaitingRoomWebSocket` 훅 개선
  - 에러 시 자동 WebSocket 정리
  - cleanup 로직 강화
2. ✅ `RealTimeQuizSidebar` 세션 체크 로직 개선
  - 프론트엔드 WebSocket 상태 확인 추가

### Phase 3: 테스트 (1일)
1. 방장 새로고침 시나리오 테스트
2. 방장 퇴장 후 다른 참가자 상태 확인
3. 방장 퇴장 후 즉시 다른 방 입장 테스트
4. 일반 참가자 새로고침 회귀 테스트

---

## 테스트 시나리오

### 시나리오 1: 방장 새로고침
1. 방장이 대기방에서 새로고침
2. AlertModal로 "방이 종료되었습니다" 표시 확인
3. 메인 페이지로 이동
4. 즉시 다른 방 입장 시도
5. **예상 결과:** 정상 입장 (WebSocket 연결이 정리되었으므로)

### 시나리오 2: 방장 새로고침 후 다른 참가자
1. 방장이 대기방에서 새로고침
2. 다른 참가자들에게 AlertModal로 방 종료 알림 확인
3. **예상 결과:** 모든 참가자가 메인으로 이동

### 시나리오 3: 일반 참가자 새로고침 (회귀 테스트)
1. 일반 참가자가 대기방에서 새로고침
2. **예상 결과:** 정상 재참가 (기존 동작 유지)

### 시나리오 4: 방장 브라우저 종료
1. 방장이 브라우저 탭 닫기
2. 다른 참가자들에게 방 종료 알림 확인
3. **예상 결과:** 세션 자동 정리

---

## 예상 효과

### 사용자 경험 개선
- ✅ 일관된 UI/UX (모든 알림이 AlertModal로 통일)
- ✅ 방장 새로고침 후 즉시 다른 방 입장 가능
- ✅ 다른 참가자들에게 적절한 알림 전달

### 기술적 개선
- ✅ 프론트엔드-백엔드 세션 상태 일치
- ✅ WebSocket 연결 정리 보장
- ✅ 메모리 누수 방지

### 유지보수성
- ✅ 명확한 에러 처리 흐름
- ✅ 로깅 및 디버깅 용이
- ✅ 테스트 가능한 구조

---

## 참고 사항

### 주의사항
- WebSocket 연결 정리는 반드시 페이지 이동 전에 수행
- 웹캠도 함께 정리하여 리소스 누수 방지
- AlertModal 닫기 전에 정리 작업 완료

### 추가 고려사항
- 방장 권한 위임 기능 추가 검토
- 방장 일시적 연결 끊김 시 재연결 로직 검토
- 모바일 환경에서의 동작 확인 필요
