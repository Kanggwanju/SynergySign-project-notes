# WebSocket 단일세션 아키텍처 면접 대비 정리

## 📌 목차
1. [핵심 깨달음](#핵심-깨달음)
2. [기술적 상황 분석](#기술적-상황-분석)
3. [실제 프로젝트 타임라인](#실제-프로젝트-타임라인)
4. [면접 답변 전략](#면접-답변-전략)
5. [추가 예상 질문](#추가-예상-질문)

---

## 핵심 깨달음

### 💡 가장 중요한 인사이트

1. **단일세션 아키텍처는 과도한 엔지니어링이었을 수 있음**
  - 애플리케이션 레벨에서 방 입장 시 참여자 확인만으로도 충분했음
  - 인프라 레벨 방어(SingleSessionChannelInterceptor)는 복잡도만 증가

2. **이중 방어 구조였다는 점**
  - 인프라 레벨: WebSocket CONNECT 단계에서 차단
  - 애플리케이션 레벨: 방 입장 단계에서 DB 검증

3. **EKS 배포로 인한 문제 발견**
  - 인프라 레벨 방어는 EKS 멀티 Pod 환경에서 작동 안 함
  - Redis 같은 외부 저장소가 필요했으나 시간 부족으로 미구현
  - 다행히 애플리케이션 레벨 방어가 있어서 핵심 기능은 보호됨

---

## 기술적 상황 분석

### 아키텍처 비교

#### 1. 제안된 간단한 방식 (애플리케이션 레벨만)

```java
// GameRoomJoinService.java
public JoinRoomResponse joinRoom(Long userId, Long gameRoomId) {
    // 이미 참여 중인지 확인
    if (participantRepository.existsByUserId(userId)) {
        throw new BusinessException("이미 참여 중입니다");
    }
    // 방 입장 처리
}
```

**장점**:
- 간단하고 직관적
- WebSocket 연결은 수립되지만 방 입장만 차단
- 멀티 Pod 환경에서도 문제없음 (DB 기반)

**단점**:
- WebSocket 연결 자체는 여러 개 가능 (리소스 다소 낭비)
- 다른 기능(채팅, 알림)도 여러 세션에서 접근 가능

---

#### 2. 실제 구현 방식 (이중 방어)

```java
// 레벨 1: 인프라 레벨
@Component
public class SingleSessionChannelInterceptor implements ChannelInterceptor {
    private final UserSessionRegistry userSessionRegistry; // ConcurrentHashMap
    
    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        if (command == CONNECT) {
            if (userSessionRegistry.hasOtherActiveSession(userId, sessionId)) {
                throw new MessagingException("DUPLICATE_SESSION");
            }
            userSessionRegistry.bind(userId, sessionId);
        }
    }
}

// 레벨 2: 애플리케이션 레벨
public JoinRoomResponse joinRoom(Long userId, Long gameRoomId) {
    // 방장이 아닌 경우: 다른 방 참여 중인지 확인
    if (!isRoomHost(userId, gameRoomId)) {
        Optional<GameRoomParticipant> existingParticipation = 
            participantRepository.findActiveByUserId(userId);
            
        if (existingParticipation.isPresent()) {
            throw new BusinessException(ErrorCode.ALREADY_IN_ROOM);
        }
    }
    // 방 입장 처리
}
```

**장점**:
- WebSocket 연결 자체를 차단 (더 근본적)
- 모든 WebSocket 기능에 일괄 적용
- 리소스를 아예 안 쓰게 함

**단점**:
- 구현 복잡도 증가
- EKS 환경에서 Redis 필요 (추가 인프라 비용)

---

### EKS 멀티 Pod 환경에서의 문제

#### 로컬 환경 (단일 서버)
```
유저 A - 탭1: WebSocket 연결 시도
└─> SingleSessionChannelInterceptor: 세션 등록 ✓
    └─> 방 A 입장 요청
        └─> GameRoomJoinService: DB 확인, 입장 허용 ✓

유저 A - 탭2: WebSocket 연결 시도
└─> SingleSessionChannelInterceptor: 중복 세션 감지! 차단 ✗

결과: 이중 방어 완벽 작동
```

#### EKS 환경 (멀티 Pod)
```
유저 A - 탭1: Pod A로 연결
└─> Pod A의 ConcurrentHashMap에 세션 등록 ✓
    └─> 방 A 입장, DB에 참여 기록 저장 ✓

유저 A - 탭2: Pod B로 연결 (Load Balancer가 다른 Pod로 라우팅)
└─> Pod B의 ConcurrentHashMap 확인 (비어있음!)
    └─> 연결 허용됨 ✗ (인프라 레벨 방어 실패)
        └─> 방 B 입장 요청
            └─> DB 확인: 이미 방 A 참여 중! 차단 ✓

결과: 
- ✅ 핵심 비즈니스 로직은 보호됨 (다중 방 입장 차단)
- ⚠️ WebSocket 연결은 여러 개 가능 (리소스 비효율)
```

---

### Redis 기반 해결 방법 (미구현)

#### 필요한 이유
EKS 환경에서는 각 Pod가 독립적인 메모리를 가지므로, 모든 Pod가 공유하는 외부 저장소 필요

#### 구현 방법
```java
@Component
public class RedisSessionRegistry {
    private final RedisTemplate<String, String> redisTemplate;
    private static final String SESSION_KEY_PREFIX = "ws:session:";
    
    public void bind(Long userId, String sessionId) {
        String key = SESSION_KEY_PREFIX + userId;
        redisTemplate.opsForValue().set(
            key, 
            sessionId,
            Duration.ofHours(24)
        );
    }
    
    public boolean hasOtherActiveSession(Long userId, String sessionId) {
        String key = SESSION_KEY_PREFIX + userId;
        String current = redisTemplate.opsForValue().get(key);
        return current != null && !current.equals(sessionId);
    }
}
```

#### 비용 고려
```
AWS ElastiCache Redis
- cache.t3.micro: 월 ~$12
- cache.t3.small: 월 ~$25 (추천)
```

---

## 실제 프로젝트 타임라인

### 개발 과정

```
1단계: 로컬 개발 (프로젝트 초기)
├─ 단일세션 아키텍처 설계 및 구현
├─ 인프라 레벨: SingleSessionChannelInterceptor + ConcurrentHashMap
├─ 애플리케이션 레벨: GameRoomJoinService 중복 검증
└─ 결과: 완벽하게 작동 ✓

2단계: 프로젝트 중반
├─ 팀에서 "EKS 한번 써보자" 제안
├─ EKS 배포 진행
└─ 문제 발견: 인프라 레벨 방어가 작동하지 않음

3단계: 문제 인식
├─ 멀티 Pod 환경에서는 Redis 필요
├─ 제약사항:
│   ├─ 남은 일정 부족
│   ├─ Redis 인프라 구축 시간 필요
│   └─ 추가 비용 발생
└─ 판단: 애플리케이션 레벨 방어로도 충분 → 일단 진행

4단계: 최종 결과
├─ 핵심 기능: 정상 작동 (다중 방 입장 차단)
├─ 기술 부채: 인프라 레벨 방어 미완성
└─ 학습: 배포 환경 고려 설계의 중요성
```

---

## 면접 답변 전략

### 🎯 추천 답변 스타일: "솔직한 회고 + 성장 강조"

#### Q1: "왜 단일 세션 방식을 선택했나요?"

**[초기 의도 설명]**
> "실시간 퀴즈 게임 특성상, 한 사용자가 여러 방에 동시 참여하면 데이터 일관성 문제가 발생할 수 있다고 판단했습니다. 그래서 이중 방어 구조로 설계했습니다."

**[구현 내용]**
> "인프라 레벨에서는 SingleSessionChannelInterceptor로 WebSocket 연결 단계에서 차단하고, 애플리케이션 레벨에서는 GameRoomJoinService에서 방 입장 시 DB 기반으로 중복 검증을 수행했습니다."

**[EKS 이슈]**
> "프로젝트 중반에 EKS 배포를 시도하면서 문제를 발견했습니다. 인프라 레벨 방어는 ConcurrentHashMap 기반이라 멀티 Pod 환경에서는 각 Pod마다 독립적인 저장소를 가지게 되어 작동하지 않았습니다. Redis 같은 외부 저장소가 필요한 상황이었습니다."

**[의사결정]**
> "남은 일정과 리소스를 고려했을 때, Redis 인프라를 구축하는 것보다 프로젝트를 완성하는 게 우선이라고 판단했습니다. 다행히 애플리케이션 레벨 방어가 DB 기반이라 멀티 Pod 환경에서도 정상 작동했고, 핵심 비즈니스 로직은 보호할 수 있었습니다."

**[회고 및 학습]**
> "돌이켜보면 처음부터 애플리케이션 레벨 검증만으로도 충분했을 수 있습니다. 이 경험을 통해 세 가지를 배웠습니다:
>
> 1. **배포 환경 고려 설계**: 로컬에서만 생각하면 안 된다
> 2. **YAGNI 원칙**: 지금 필요한 것만 구현하기
> 3. **방어 레이어의 가치**: 한 레이어가 실패해도 다른 레이어가 시스템을 보호함
>
> 만약 다시 설계한다면, 초기에는 애플리케이션 레벨 검증만 구현하고, 실제 성능 이슈가 생기면 그때 인프라 레벨로 내리되 처음부터 Redis를 고려하겠습니다."

---

#### Q2: "EKS에서 Redis를 쓰지 않은 이유는?"

**[상황 설명]**
> "저희는 개발 초기에는 로컬 환경에서 작업했고, 프로젝트 중반에 EKS 배포를 시도했습니다. EKS를 사용한다는 결정이 나중에 이루어진 거죠."

**[문제 발견]**
> "EKS 배포 후에 멀티 Pod 환경에서는 인메모리 세션 저장소가 작동하지 않는다는 걸 알게 됐습니다. 이론적으로는 Redis로 전환해야 맞습니다."

**[의사결정 과정]**
> "하지만 몇 가지 제약사항이 있었습니다:
> - 프로젝트 마감까지 남은 시간
> - Redis 인프라 구축 및 테스트 시간
> - 추가 비용 발생 (ElastiCache 월 ~$25)
> - 팀원들의 Redis 경험 부족
>
> 가장 중요한 건, 애플리케이션 레벨 방어가 정상 작동해서 핵심 비즈니스 로직은 보호되고 있었다는 점입니다. 완벽하진 않지만 동작하는 제품을 만드는 게 우선이라고 판단했습니다."

**[실용적 선택]**
> "결과적으로 WebSocket 연결은 여러 개 가능했지만, 실제 방 입장은 DB 검증으로 차단됐습니다. 리소스 효율은 완벽하지 않았지만, 사용자 경험에는 문제가 없었습니다."

**[향후 개선 계획]**
> "만약 프로덕션 환경이었다면, 다음 스프린트에서 Redis 마이그레이션을 기술 부채로 등록하고 우선순위를 평가했을 겁니다. 실제 트래픽 패턴을 보고 리소스 비효율이 얼마나 발생하는지 측정한 후 결정하는 게 맞다고 생각합니다."

---

#### Q3: "단일세션이 과도한 엔지니어링이었다고 생각하나요?"

**[솔직한 인정]**
> "네, 돌이켜보면 과도한 엔지니어링이었을 수 있습니다. 애플리케이션 레벨에서 방 입장 시 참여자 검증만으로도 충분했을 거예요."

**[당시 의도]**
> "당시에는 학습한 내용을 적용하고 싶은 마음이 컸고, '더 근본적인 레벨에서 막으면 더 좋지 않을까?'라는 생각으로 인프라 레벨 방어까지 추가했습니다."

**[긍정적 측면]**
> "하지만 이 과정에서 얻은 게 많습니다:
> - WebSocket 연결 관리에 대한 깊은 이해
> - 스테일 세션, 하트비트 같은 실시간 시스템의 엣지 케이스
> - 분산 시스템에서의 상태 관리 문제
> - 인메모리 vs 외부 저장소의 Trade-off
> - 이중 방어 덕분에 EKS 이슈에도 시스템이 버틸 수 있었음"

**[학습 포인트]**
> "실무에서는 '완벽한 아키텍처'보다 '적절한 복잡도'가 중요하다는 걸 배웠습니다. 그리고 과도한 엔지니어링도 학습 과정에서는 가치가 있다고 생각합니다. 실패에서 배우는 게 더 오래 기억에 남거든요."

---

#### Q4: "프로젝트를 다시 한다면 어떻게 하시겠어요?"

**[설계 접근]**
> "처음부터 배포 환경을 고려한 설계를 하겠습니다. 팀과 '로컬만 쓸 건지, 클라우드 배포까지 갈 건지'를 먼저 합의하고 시작할 거예요."

**[단계별 접근]**
> "**Phase 1 (MVP)**:
> - 애플리케이션 레벨 검증만 구현 (DB 기반)
> - 간단하고 모든 환경에서 작동
> - 빠르게 프로토타입 완성
>
> **Phase 2 (필요시)**:
> - 실제 트래픽 패턴 분석
> - 리소스 비효율이 실제 문제가 되는지 측정
> - 문제가 있다면 그때 인프라 레벨 방어 추가
>
> **Phase 3 (스케일 아웃)**:
> - EKS/멀티 서버 환경 전환 시
> - 처음부터 Redis 같은 분산 저장소 설계에 포함"

**[기술 스택 선택]**
> "만약 처음부터 EKS를 쓸 계획이었다면:
> - Spring Session + Redis: 세션 관리
> - Redis Pub/Sub: 서버 간 이벤트 동기화
> - Sticky Session: WebSocket 연결 유지
>
> 이렇게 인프라부터 분산 환경을 가정하고 설계했을 겁니다."

**[의사소통]**
> "가장 중요한 건 팀 내 기술 결정 과정을 명확히 하는 거라고 생각합니다. '왜 이렇게 했는지', '어떤 Trade-off가 있는지'를 문서화하고 공유했다면, EKS 도입 시점에 더 빠르게 대응할 수 있었을 것 같습니다."

---

#### Q5: "이 경험에서 가장 중요하게 배운 점은?"

**[핵심 학습]**
> "세 가지입니다:
>
> **1. 실용주의 (Pragmatism)**
> - 완벽한 설계보다 동작하는 제품이 먼저
> - 기술 부채는 인정하되, 우선순위를 명확히
> - '나중에' 개선할 수 있지만, '지금' 완성하지 못하면 의미 없음
>
> **2. 배포 환경 고려 설계**
> - 로컬에서만 생각하면 안 됨
> - 초기 설계에서 'Scale-out하면?'을 먼저 질문
> - 인메모리 저장소는 분산 환경에서 함정
>
> **3. 방어적 다층 설계의 가치**
> - 한 레이어가 실패해도 다른 레이어가 보호
> - 과도한 엔지니어링이라 생각했지만, 결과적으로 시스템을 살림
> - 하지만 '필요한 복잡도'와 '불필요한 복잡도'를 구분하는 안목 필요"

**[마인드셋 변화]**
> "주니어일 때는 '최신 기술, 완벽한 아키텍처'를 추구했다면, 이제는 '적절한 기술, 충분한 아키텍처'를 추구하게 됐습니다. 하지만 동시에, 과도한 엔지니어링도 학습 과정에서는 충분히 가치 있다고 생각합니다."

---

## 추가 예상 질문

### Q6: "Redis 말고 다른 해결 방법은 없었나요?"

**답변**:
> "몇 가지 대안이 있었습니다:
>
> **1. Sticky Session (로드 밸런서 설정)**
> - 같은 사용자는 항상 같은 Pod로 라우팅
> - 장점: Redis 불필요
> - 단점: Pod 재시작 시 세션 유실, 스케일링 시 불균형
>
> **2. DB 기반 세션 저장소**
> - PostgreSQL에 세션 테이블 추가
> - 장점: 별도 인프라 불필요
> - 단점: DB 부하 증가, 속도 느림
>
> **3. Hazelcast (인메모리 데이터 그리드)**
> - 분산 ConcurrentHashMap
> - 장점: 빠름, Auto-discovery
> - 단점: 학습 곡선, 복잡도 증가
>
> Redis를 선택한 이유는 업계 표준이고, Spring Boot와 통합이 잘 되며, 향후 캐싱 등 다른 용도로도 활용 가능하기 때문입니다."

---

### Q7: "단일세션 정책의 단점은 없나요?"

**답변**:
> "물론 있습니다:
>
> **사용자 경험 측면**:
> - 사용자가 여러 탭에서 동시 작업 불가
> - 실수로 새 탭을 열면 기존 연결이 끊김 (또는 새 탭이 차단됨)
>
> **하지만 우리 도메인(실시간 퀴즈 게임)에서는**:
> - 게임 중에는 한 탭에만 집중함
> - 여러 방에 동시 참여할 필요가 없음
> - First-Come 방식으로 게임 중 실수로 새 탭 열어도 기존 게임 보호
>
> **완화 방법**:
> - 명확한 에러 메시지: '다른 탭에서 이미 접속 중'
> - 기존 탭 닫으면 자동 재연결 가능
>
> **향후 확장**:
> - 관전 모드 같은 기능이 필요하면
> - 세션 타입 구분 (PLAYER/SPECTATOR)
> - 선택적으로 다중 세션 허용 가능"

---

### Q8: "스테일 세션 문제는 어떻게 해결했나요?"

**답변**:
> "스테일 세션은 단일세션 정책에서 특히 치명적입니다. 죽은 세션이 새로운 정상 연결을 막을 수 있거든요.
>
> **해결 방법**:
>
> 1. **하트비트 설정**
> ```javascript
> heartbeatIncoming: 30000,
> heartbeatOutgoing: 30000
> ```
> - 30초마다 연결 확인
> - 끊긴 연결 자동 감지
>
> 2. **이벤트 리스너 분리**
> - SingleSessionChannelInterceptor: 바인딩 및 검증
> - WebSocketEventsListener: 정리 (finally 블록에서 항상 실행)
>
> 3. **활성 세션 검증**
> - DISCONNECT 처리 시 활성 세션인지 재확인
> - 비활성 세션의 정리 시도는 무시
>
> 4. **TTL 설정 (Redis 사용 시)**
> - 세션에 24시간 TTL 부여
> - 자동 만료로 스테일 세션 방지
>
> 이 문제를 해결하면서 '보호 정책이 오히려 방해가 되는 상황'을 어떻게 다뤄야 하는지 배웠습니다."

---

### Q9: "성능 테스트는 했나요?"

**솔직한 답변**:
> "아니요, 제대로 된 부하 테스트는 못 했습니다. 시간 제약과 부하 테스트 환경 구축의 어려움 때문이었습니다.
>
> **했던 것**:
> - 팀원들과 동시 접속 테스트 (5-10명)
> - 브라우저 여러 탭 열어서 중복 세션 차단 확인
> - 네트워크 끊김 시뮬레이션 (개발자 도구 오프라인 모드)
>
> **하지 못한 것**:
> - 100+ 동시 접속자 부하 테스트
> - 멀티 Pod 환경에서 세션 분산 테스트
> - Redis 장애 시나리오 테스트
>
> **만약 실무였다면**:
> - JMeter나 Gatling으로 부하 테스트
> - CloudWatch로 메트릭 수집
> - 점진적으로 부하를 늘리며 병목 지점 파악
> - 이를 바탕으로 Redis 도입 여부 결정
>
> 이 부분은 프로젝트의 아쉬운 점이고, 다음에는 꼭 보완하고 싶습니다."

---

### Q10: "팀원들과 기술 결정은 어떻게 했나요?"

**답변**:
> "초기에는 제가 단일세션 아키텍처를 설계하고 구현했습니다. 팀원들에게 설명했을 때는 긍정적인 반응이었고, 로컬 환경에서 잘 작동했기 때문에 문제가 없어 보였습니다.
>
> **EKS 도입 시점**:
> - 팀에서 '배포 경험을 위해 EKS 써보자'는 제안
> - 저는 당시 EKS가 멀티 Pod 환경이라는 걸 몰랐음
> - 배포 후 세션 문제 발견
>
> **문제 발견 후**:
> - 팀원들과 상황 공유
> - Redis 도입 vs 현상 유지 논의
> - 일정과 리소스 고려해서 현상 유지 결정
>
> **아쉬운 점**:
> - 기술 결정 과정을 문서화하지 않음
> - Trade-off를 명확히 공유하지 않음
> - '왜 이렇게 했는지' ADR(Architecture Decision Record) 작성했으면 좋았을 것
>
> **배운 점**:
> - 혼자 결정하지 말고 팀과 논의
> - 특히 인프라 결정은 전체 시스템에 영향
> - 기술 부채는 숨기지 말고 명확히 공유"

---

## 💬 면접관이 좋아할 포인트

### ✅ 긍정적으로 보일 수 있는 부분

1. **솔직함과 자기 인식**
  - "과도한 엔지니어링이었을 수 있다"고 인정
  - 완벽하지 않았지만 배운 점을 명확히 설명

2. **실용적 의사결정**
  - 완벽한 아키텍처보다 동작하는 제품 우선
  - 제약 조건 속에서 최선의 선택

3. **깊은 기술 이해**
  - 단순히 구현만 한 게 아니라 WHY를 고민
  - 분산 시스템의 복잡성을 경험으로 체득

4. **성장 마인드셋**
  - 실수에서 배우는 자세
  - "다시 한다면 이렇게 하겠다" 구체적 개선 방향

5. **Trade-off 이해**
  - 모든 선택에는 장단점이 있음을 인지
  - 상황에 맞는 적절한 복잡도 추구

---

## 🚨 주의할 점

### ❌ 피해야 할 답변 스타일

1. **과도한 변명**
  - "시간이 없어서", "팀이 그렇게 하자고 해서"만 반복
  - → 대신: "제약 조건 속에서 이런 판단을 했고, 그 결과..."

2. **기술 과시**
  - Redis, EKS, Kubernetes 용어만 나열
  - → 대신: "왜 이 기술이 필요했는지" 맥락 설명

3. **책임 회피**
  - "제가 한 게 아니라 다른 팀원이..."
  - → 대신: "팀의 결정이었고, 저는 이렇게 기여했으며..."

4. **완벽주의**
  - "모든 걸 완벽하게 했습니다"
  - → 대신: "이 부분은 잘했고, 저 부분은 아쉬웠으며, 배운 점은..."

---

## 📝 핵심 키워드 정리

면접에서 자연스럽게 언급하면 좋은 키워드들:

### 기술 키워드
- WebSocket, STOMP, Spring Boot
- Single Session, First-Come First-Served
- ConcurrentHashMap, Redis, ElastiCache
- EKS, Kubernetes, Multi-Pod
- 인프라 레벨 vs 애플리케이션 레벨
- Trade-off, 기술 부채

### 소프트 스킬 키워드
- 실용주의 (Pragmatism)
- YAGNI (You Aren't Gonna Need It)
- 의사결정 (Decision Making)
- 우선순위 (Priority)
- 회고 (Retrospective)
- 성장 마인드셋 (Growth Mindset)

---

## 🎓 마무리: 이 경험의 진짜 가치

### 기술적 가치
- ✅ WebSocket 연결 관리 깊이 있게 이해
- ✅ 분산 시스템의 상태 관리 문제 체험
- ✅ 배포 환경 고려 설계의 중요성

### 실무적 가치
- ✅ 제약 조건 속 의사결정 경험
- ✅ 기술 부채 관리 경험
- ✅ 실패에서 배우는 자세

### 면접 전략
이 경험을 말할 때:
1. **솔직하게** - 완벽하지 않았다고 인정
2. **구체적으로** - 어떤 문제였고, 어떻게 대응했는지
3. **성장 중심으로** - 무엇을 배웠고, 어떻게 개선할지
4. **실용적으로** - 이상과 현실의 균형

> "과도한 엔지니어링이었지만, 그래서 더 많이 배웠습니다."

이게 가장 좋은 스토리입니다! 🚀

---

**작성일**: 2025-11-18  
**버전**: 1.0  
**작성자**: Claude & 판주