# 세부사항 논의


## 현재 진행 라운드 추적

우리 서비스 시나리오:
1라운드 완료 → 대기실 복귀 → 준비 → 2라운드 시작 → ...

따로 라운드에 대한 정보가 없으므로 game_history 엔티티에서 역으로 추론해야 함.
-> 복잡한 과정을 거칠 것으로 예상됨.

대기실 입장: 이게 첫 대기실인지, 1라운드 후 대기실인지, 2라운드 후 대기실인지 모름
GameRoom 클래스에 currentRound  필드를 추가하면 해결 가능
```
@Column(nullable = false)
private Integer currentRound;  // 현재 진행 중인 라운드
```

---


## 퀴즈 게임 진행 관련

문제 1~7: 메모리(Redis/HashMap)에서 점수 관리
↓
실시간 UI 업데이트 (WebSocket)
↓
문제 8 완료: 최종 점수를 DB에 저장


---

## 전체 게임 방 목록 조회 방식

1. 무한스크롤
2. 페이지
3. 한번에 얼마나 가져올지
4. 필터링은 어떻게 할지

---

## 퀴즈 게임 랜덤 단어 처리 방식

웹소켓
- 퀴즈 시작: `/app/rooms/{roomId}/start`
- 문제 출제: `/topic/rooms/{roomId}`

```text
1. 퀴즈 시작
   ↓
[메모리] roomId: 123 → [word1, word2, ..., word8]
[메모리] currentIndex: 0

2. 첫 번째 문제 출제
   ↓
메모리에서 questions[0] 가져오기
   ↓
WebSocket → { wordId: 5, title: "사랑해요" }

3. 답변 제출
   ↓
currentIndex++

4. 두 번째 문제 출제
   ↓
메모리에서 questions[1] 가져오기
   ↓
WebSocket → { wordId: 12, title: "고마워요" }

...

9. 8번째 문제 답변 완료
   ↓
라운드 종료
   ↓
메모리 정리 (roomQuestions, currentIndex 삭제)
```

---

## 점수 표시 시나리오

### 유저의 "총 점수"를 보여줘야 하는 시점:

1. **방 입장 시** - 다른 참가자들의 총 점수 확인
2. **대기실에서** - 실시간으로 누가 들어오는지 + 그 사람 총 점수
3. **프로필 조회** - 내 총 점수 확인

---

## 답변: **HTTP, WebSocket 둘 다 필요**

### 1. **HTTP (REST API)** - 총 점수 조회

#### 사용 시점:
- 방 정보를 **처음 조회**할 때
- 프로필 페이지에서 **내 점수** 확인

#### API 예시:
```
// 방 상세 조회 시 참가자 점수 포함
GET /api/quiz/rooms/{roomId}

// 응답
{
  "participants": [
    {
      "userId": 1,
      "nickname": "홍길동",
      "totalScore": 2450,  // 👈 게임 히스토리 합산
      "isHost": true,
      "isReady": true
    },
    {
      "userId": 2,
      "nickname": "김영희",
      "totalScore": 1820,  // 👈 게임 히스토리 합산
      "isHost": false,
      "isReady": false
    }
  ]
}
```

---

### 2. **WebSocket** - 실시간 점수 동기화

#### 사용 시점:
- **새로운 유저가 입장**할 때 → 모든 참가자에게 알림
- 대기실에서 실시간으로 업데이트

#### WebSocket 이벤트:
```
// 유저 입장 시
DESTINATION: /topic/rooms/{roomId}
{
  "type": "user_joined",
  "data": {
    "user": {
      "userId": 3,
      "nickname": "박민수",
      "totalScore": 980,  // 👈 DB에서 계산해서 포함
      "isHost": false,
      "isReady": false
    },
    "room": {
      "participants": [
        {
          "userId": 1,
          "nickname": "홍길동",
          "totalScore": 2450
        },
        {
          "userId": 2,
          "nickname": "김영희",
          "totalScore": 1820
        },
        {
          "userId": 3,
          "nickname": "박민수",
          "totalScore": 980
        }
      ]
    }
  }
}
```

---

## 🚀 성능 최적화 (선택사항)

### 문제:
- 매번 `SUM(score)` 계산하면 **느림**

### 해결책 1: **User 엔티티에 totalScore 필드 추가**

```java
@Entity
public class User {
    
    @Id
    private Long id;
    
    private String nickname;
    
    // 👇 총 점수 캐시
    @Column(nullable = false)
    private Integer totalScore = 0;
    
    // 점수 업데이트
    public void addScore(int score) {
        this.totalScore += score;
    }
}
```

```java
// 라운드 종료 시 점수 업데이트
@Service
public class QuizService {
    
    public void endRound(Long roomId) {
        Map<Long, Integer> finalScores = scoreManager.getRoundScores(roomId);
        
        finalScores.forEach((userId, score) -> {
            User user = userRepository.findById(userId).orElseThrow();
            
            // 1. 히스토리 저장
            gameHistoryRepository.save(GameHistory.builder()
                .participant(user)
                .score(score)
                .build());
            
            // 2. 유저 총 점수 업데이트 👈
            user.addScore(score);
            userRepository.save(user);
        });
    }
}
```

**장점:**
- ✅ 매번 SUM 계산 불필요
- ✅ 빠른 조회 (`user.getTotalScore()`)

**단점:**
- ❌ 데이터 중복 (정규화 위반)
- ❌ 동기화 관리 필요

---

### 해결책 2: **Redis 캐싱**

```java
@Service
public class UserService {
    
    @Autowired
    private RedisTemplate<String, Integer> redisTemplate;
    
    public int calculateTotalScore(Long userId) {
        String cacheKey = "user:totalScore:" + userId;
        
        // 1. 캐시 확인
        Integer cached = redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // 2. DB 계산
        Integer totalScore = gameHistoryRepository.sumScoreByUserId(userId);
        int score = totalScore != null ? totalScore : 0;
        
        // 3. 캐시 저장 (1시간)
        redisTemplate.opsForValue().set(cacheKey, score, 1, TimeUnit.HOURS);
        
        return score;
    }
    
    // 점수 업데이트 시 캐시 무효화
    public void invalidateTotalScoreCache(Long userId) {
        String cacheKey = "user:totalScore:" + userId;
        redisTemplate.delete(cacheKey);
    }
}
```

---

## 📋 정리

### **HTTP vs WebSocket**

| 상황 | 사용 방법 | 이유 |
|-----|---------|------|
| 방 상세 조회 | **HTTP** | 페이지 로드 시 한 번만 |
| 프로필 조회 | **HTTP** | 내 점수 확인 |
| 유저 입장 알림 | **WebSocket** | 실시간 동기화 |
| 대기실 업데이트 | **WebSocket** | 실시간 동기화 |

### **MVP 단계 추천**
1. **SQL SUM으로 계산** (간단)
2. 나중에 **User.totalScore 필드 추가** (성능 개선)
3. 트래픽 많아지면 **Redis 캐싱** (확장성)

