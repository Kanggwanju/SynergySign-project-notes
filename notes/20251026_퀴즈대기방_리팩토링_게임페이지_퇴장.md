# 퀴즈 대기방 리팩토링 및 게임 페이지 퇴장 로직 구현 - 해결 방안

## 🔥 필독: 백엔드 퇴장 로직의 핵심

**백엔드에는 명시적인 퇴장 API(`/leave`, `/exit` 등)가 존재하지 않습니다!**

백엔드는 **이벤트 기반 자동 퇴장 처리** 방식을 사용합니다:
- 프론트엔드가 `websocketService.disconnect()`를 호출하면
- 백엔드가 WebSocket DISCONNECT 이벤트를 자동 감지
- `GameRoomLeaveService`가 자동으로 모든 퇴장 처리 수행
- 다른 참가자들에게 자동으로 알림 전송

**프론트엔드는 단순히 disconnect()만 호출하면 됩니다!**

---

## 목차
1. [문제 분석](#1-문제-분석)
2. [백엔드 퇴장 로직 분석](#2-백엔드-퇴장-로직-분석)
3. [프론트엔드 퇴장 로직 분석](#3-프론트엔드-퇴장-로직-분석)
4. [해결 방안](#4-해결-방안)
5. [구현 가이드](#5-구현-가이드)

---

## 1. 문제 분석

### 1.1 QuizWaitingRoom의 문제점

#### 코드 복잡도
- **현재 상태**: 600+ 줄의 단일 파일에 모든 로직 집중
- **문제점**:
  - WebSocket, Janus, 웹캠, 상태 관리가 모두 한 곳에 있어 유지보수 어려움
  - 로직 재사용 불가능
  - 테스트 작성 어려움
  - 코드 가독성 저하

#### 구조적 문제
```javascript
// 현재: 모든 것이 하나의 컴포넌트에
QuizWaitingRoom.jsx (600+ lines)
├── useState (10+ 개의 상태)
├── useEffect (8+ 개의 이펙트)
├── 이벤트 핸들러 (15+ 개)
├── Janus 연결 로직 (200+ lines)
├── WebSocket 로직 (100+ lines)
└── JSX 렌더링 (200+ lines)
```

### 1.2 QuizGamePage의 문제점

#### 퇴장 로직 부재
- **현재 상태**: `handleExit`와 `confirmExit`가 있지만 단순히 메인으로 이동만 함
- **문제점**:
  - WebSocket 연결이 정리되지 않음
  - Janus WebRTC 연결이 남아있음
  - FastAPI WebSocket 연결이 끊어지지 않음
  - 녹화가 중단되지 않음
  - 백엔드에 퇴장 알림이 전송되지 않음

#### 리소스 누수 위험
```javascript
// 현재 confirmExit (문제 있음)
const confirmExit = () => navigate('/main');

// 정리되지 않는 리소스들:
// 1. janusRef.current - Janus 세션
// 2. pluginHandleRef.current - VideoRoom 플러그인
// 3. remoteFeedsRef.current - 원격 피드들
// 4. quizFastApi 연결 - FastAPI WebSocket
// 5. recordingRef.current - 녹화 애니메이션 프레임
// 6. websocketService - Spring Boot WebSocket
```

---

## 2. 백엔드 퇴장 로직 분석

### 2.1 퇴장 처리 흐름

#### 전체 아키텍처
```
[클라이언트]
    ↓ WebSocket DISCONNECT
[WebSocketEventsListener]
    ↓ onDisconnect()
[WebSocketSessionService]
    ↓ handleSessionDisconnect()
    ├─ 활성 세션 검증
    ├─ 방 퇴장 처리 위임
    └─ 세션 정리
        ↓
[GameRoomLeaveService]
    ↓ leaveCurrentRoomByUser()
    ├─ 참가자 조회
    └─ leaveRoom()
        ├─ 방장? → handleHostLeave()
        └─ 일반? → handleParticipantLeave()
```

### 2.2 핵심 코드 분석

#### WebSocketEventsListener.java
```java
@EventListener
public void onDisconnect(SessionDisconnectEvent event) {
    DisconnectInfo disconnectInfo = extractDisconnectInfo(event);
    if (disconnectInfo == null) return;
    
    // 실제 처리는 SessionManager에게 위임
    sessionManager.handleSessionDisconnect(
        disconnectInfo.userId(),
        disconnectInfo.sessionId()
    );
}
```
**역할**: WebSocket 연결 해제 이벤트를 감지하고 정보 추출



#### WebSocketSessionService.java
```java
public boolean handleSessionDisconnect(Long userId, String sessionId) {
    try {
        // 1. 활성 세션 검증 (스테일 세션 무시)
        if (!isActiveSession(userId, sessionId)) {
            log.info("비활성 세션의 DISCONNECT 무시");
            return false;
        }
        
        // 2. 방 퇴장 처리
        handleRoomLeave(userId);
        
        return true;
    } finally {
        // 3. 세션 정리 (항상 실행)
        cleanupSession(userId, sessionId);
    }
}

private void handleRoomLeave(Long userId) {
    ParticipantEventResponse eventResp = leaveService.leaveCurrentRoomByUser(userId);
    Long roomId = eventResp.getGameRoomId();
    
    // 같은 방의 다른 참가자들에게 퇴장 알림 브로드캐스트
    broadcastLeaveEvent(roomId, eventResp);
}
```
**역할**: 세션 검증, 방 퇴장 조율, 세션 정리

#### GameRoomLeaveService.java - 일반 참가자 퇴장
```java
private ParticipantEventResponse handleParticipantLeave(
    GameParticipant participant,
    GameRoom room,
    ParticipantResponse participantResponse,
    Long userId,
    Long gameRoomId
) {
    // 1. 참가자 정보 삭제
    participantRepository.delete(participant);
    
    // 2. 방의 현재 참가자 수 감소
    room.decrementParticipants();
    
    // 3. 게임 진행 중이면 캐시에서 해당 유저 제거
    if (room.getStatus() == GameRoomStatus.IN_PROGRESS) {
        handleGameInProgressLeave(gameRoomId, userId);
    }
    
    // 4. 업데이트된 게임방 정보 저장
    gameRoomRepository.save(room);
    
    // 5. 퇴장 이벤트 응답 생성
    return ParticipantEventResponse.builder()
        .eventType("PARTICIPANT_LEFT")
        .participant(participantResponse)
        .currentParticipants(room.getCurrentParticipants())
        .gameRoomId(room.getId())
        .roomClosed(false)
        .build();
}
```
**역할**: 일반 참가자 퇴장 처리 (DB 삭제, 인원 감소, 캐시 정리)



#### GameRoomLeaveService.java - 방장 퇴장 (방 종료)
```java
private ParticipantEventResponse handleHostLeave(GameRoom room, ParticipantResponse hostResponse) {
    Long roomId = room.getId();
    
    // 1. 방장 제외한 다른 참가자들의 userId 목록 조회
    List<Long> otherParticipantUserIds = participantRepository
        .findByGameRoom_Id(roomId)
        .stream()
        .filter(p -> !p.isHost())
        .map(p -> p.getParticipant().getId())
        .toList();
    
    // 2. 남은 모든 참가자를 한 번의 쿼리로 삭제 (Bulk Delete)
    int deletedCount = participantRepository.deleteAllByGameRoom(room);
    
    // 3. 방 종료 처리
    room.closeRoom();
    
    // 4. 업데이트된 방 정보 저장
    gameRoomRepository.save(room);
    
    // 5. 남은 참가자들의 세션 정리
    if (!otherParticipantUserIds.isEmpty()) {
        sessionService.cleanupMultipleSessions(otherParticipantUserIds, roomId);
    }
    
    // 6. 방 종료 이벤트 응답 생성
    return ParticipantEventResponse.builder()
        .eventType("ROOM_CLOSED")
        .participant(hostResponse)
        .currentParticipants(0)
        .gameRoomId(roomId)
        .roomClosed(true)
        .build();
}
```
**역할**: 방장 퇴장 시 방 종료 처리 (모든 참가자 제거, 방 상태 변경, 세션 정리)

#### GameRoomLeaveService.java - 게임 중 퇴장 처리
```java
private void handleGameInProgressLeave(Long roomId, Long userId) {
    QuizStateCache.GameRoomState roomState = quizStateCache.getOrCreateRoomState(roomId);
    
    // 1. 캐시에서 점수 제거
    roomState.removeUserScore(userId);
    
    // 2. 모든 문제(1~8)에서 해당 유저의 도전 순서 제거 및 차례 확인
    for (int questionNumber = 1; questionNumber <= 8; questionNumber++) {
        // 현재 도전 차례인지 확인
        Long currentChallenger = roomState.getCurrentChallenger(questionNumber);
        boolean wasCurrentChallenger = userId.equals(currentChallenger);
        
        // 도전 순서에서 제거
        roomState.removeChallenger(questionNumber, userId);
        
        // 도전 차례였다면 다음 도전자에게 넘김
        if (wasCurrentChallenger) {
            Long nextChallenger = roomState.getNextChallenger(questionNumber);
            // 다음 도전자 이벤트 전송 필요
        }
    }
}
```
**역할**: 게임 진행 중 퇴장 시 캐시 정리 및 다음 도전자 처리



### 2.3 백엔드 퇴장 이벤트 타입

#### PARTICIPANT_LEFT (일반 참가자 퇴장)
```json
{
  "success": true,
  "message": "사용자가 연결을 끊었습니다.",
  "data": {
    "eventType": "PARTICIPANT_LEFT",
    "participant": {
      "userId": 123,
      "nickname": "사용자1",
      "profileImageUrl": "...",
      "host": false,
      "ready": false
    },
    "currentParticipants": 3,
    "gameRoomId": 456,
    "roomClosed": false
  }
}
```

#### ROOM_CLOSED (방장 퇴장 - 방 종료)
```json
{
  "success": true,
  "message": "사용자가 연결을 끊었습니다.",
  "data": {
    "eventType": "ROOM_CLOSED",
    "participant": {
      "userId": 123,
      "nickname": "방장",
      "profileImageUrl": "...",
      "host": true,
      "ready": false
    },
    "currentParticipants": 0,
    "gameRoomId": 456,
    "roomClosed": true
  }
}
```

### 2.4 백엔드 퇴장 로직 특징

#### 핵심 설계 철학
**🔥 중요: 백엔드에는 명시적인 퇴장 API가 존재하지 않습니다!**

백엔드는 **이벤트 기반 자동 퇴장 처리** 방식을 채택했습니다:
- 클라이언트가 `websocketService.disconnect()`를 호출하면
- WebSocket 연결이 끊어지고
- 백엔드의 `WebSocketEventsListener`가 DISCONNECT 이벤트를 자동 감지
- 자동으로 방 퇴장 처리 및 알림 전송

#### 장점
1. **완전 자동화**: 클라이언트는 단순히 연결만 끊으면 됨 (API 호출 불필요)
2. **네트워크 장애 대응**: 브라우저 강제 종료, 네트워크 끊김 등 모든 경우 자동 처리
3. **트랜잭션 안전성**: @Transactional로 롤백 보장
4. **스테일 세션 방지**: 활성 세션만 처리하여 중복 처리 방지
5. **방 종료 자동화**: 방장 퇴장 시 자동으로 방 종료 및 참가자 정리
6. **게임 상태 관리**: 게임 중 퇴장 시 캐시 정리 및 다음 도전자 처리

#### 프론트엔드 구현 시 주의사항
1. **명시적 퇴장 API 호출 금지**: `/leave`, `/exit` 같은 엔드포인트 없음
2. **단순히 disconnect만 호출**: `websocketService.disconnect()` 만으로 충분
3. **백엔드가 모든 것을 처리**: 방 퇴장, 알림 전송, 세션 정리 모두 자동
4. **게임 중 퇴장 시 다음 도전자 이벤트**: 현재 구현에서 누락 가능성
5. **방 종료 알림**: `/user/queue/room-closed`로 개별 전송

---

## 3. 프론트엔드 퇴장 로직 분석

### 3.1 QuizWaitingRoom의 퇴장 로직 (현재 구현)

#### cleanupAndExit 함수
```javascript
const cleanupAndExit = async () => {
    try {
        console.log('🚪 방 나가기 처리 시작 (Merged)');
        
        // 1. Janus WebRTC 정리 (Context 사용)
        if (janusRef.current) {
            try {
                janusRef.current.destroy();
                janusRef.current = null;
                pluginHandleRef.current = null;
                remoteFeedsRef.current = {};
                userIdToFeedIdRef.current = {};
                setIsJanusConnected(false);
                setRemoteStreams({});
                console.log('✅ Janus 정리 완료');
            } catch (error) {
                console.error('Janus 정리 실패:', error);
            }
        }
        
        // 2. 웹캠 정리 (useWebcamStore 사용)
        if (isWebcamOn) {
            stopWebcam();
            console.log('✅ 웹캠 정리 완료 (via store)');
        }
        
        // 3. WebSocket 연결 해제
        websocketService.disconnect();
        console.log('✅ WebSocket 연결 해제 완료 (서버가 자동으로 퇴장 처리)');
        
        // 4. 메인 페이지로 이동
        navigate('/main');
    } catch (error) {
        console.error('❌ 방 나가기 실패:', error);
        navigate('/main'); // 실패 시에도 강제 이동
    }
};
```



#### 퇴장 로직 분석
**정리 순서**:
1. Janus WebRTC 연결 종료
2. 웹캠 스트림 정지
3. WebSocket 연결 해제 (백엔드가 자동으로 퇴장 처리)
4. 메인 페이지로 이동

**장점**:
- 모든 리소스를 순차적으로 정리
- try-catch로 에러 처리
- finally 없이도 실패 시 강제 이동

**개선 필요**:
- 600줄 컴포넌트에 포함되어 재사용 불가
- 게임 페이지에서 사용할 수 없음

### 3.2 QuizGamePage의 퇴장 로직 (현재 구현)

#### 현재 코드
```javascript
const handleExit = () => setShowExitModal(true);
const confirmExit = () => navigate('/main');
```

#### 문제점
1. **리소스 정리 없음**: 단순히 페이지만 이동
2. **WebSocket 연결 유지**: 백엔드에 퇴장 알림 없음
3. **Janus 연결 유지**: 메모리 누수 발생
4. **FastAPI 연결 유지**: AI 서버 연결 유지
5. **녹화 계속 진행**: 애니메이션 프레임 계속 실행

#### 필요한 정리 작업
```javascript
// 게임 페이지에서 추가로 정리해야 할 것들:
1. isRecordingRef.current = false
2. cancelAnimationFrame(recordingRef.current)
3. quizFastApi.disconnect()
4. fastApiConnectedRef.current = false
5. metaSentRef.current = false
6. + QuizWaitingRoom의 cleanupAndExit 로직
```

### 3.3 게임에서 대기실 복귀 로직 (현재 구현)

#### handleReturnToRoom 함수
```javascript
const handleReturnToRoom = async () => {
    console.log('🚪 대기실로 돌아가기 요청');
    
    // 1. WebRTC 연결 완전 정리
    // Remote feeds 정리
    if (remoteFeedsRef.current && Object.keys(remoteFeedsRef.current).length > 0) {
        Object.values(remoteFeedsRef.current).forEach(feed => {
            if (feed && typeof feed.detach === 'function') {
                feed.detach();
            }
        });
        remoteFeedsRef.current = {};
    }
    
    // Publisher 정리 - Janus 방 떠나기
    if (pluginHandleRef.current) {
        await new Promise((resolve) => {
            const leave = { request: 'leave' };
            pluginHandleRef.current.send({ 
                message: leave,
                success: () => resolve(),
                error: () => resolve()
            });
            setTimeout(resolve, 500);
        });
        pluginHandleRef.current.detach();
        pluginHandleRef.current = null;
    }
    
    // Janus 연결 종료
    if (janusRef.current) {
        janusRef.current.destroy();
        janusRef.current = null;
    }
    
    // 상태 초기화
    setRemoteStreams({});
    setIsJanusConnected(false);
    userIdToFeedIdRef.current = {};
    
    // 2. 대기실로 이동
    navigate(`/quiz/waiting/${roomId}`, {
        state: {
            returnFromGame: true,
            needsRejoin: true
        }
    });
};
```



#### 특징
- **Janus 방 명시적 떠나기**: `leave` 요청 전송
- **Promise 기반 비동기 처리**: 타임아웃 포함
- **WebSocket 유지**: 대기실에서 재사용
- **웹캠 유지**: 대기실에서 계속 사용

---

## 4. 해결 방안

### 4.1 전체 아키텍처 설계

#### 목표 구조
```
[공통 훅]
useRoomExit.js
├─ Janus 정리
├─ 웹캠 정리
├─ WebSocket 해제
└─ 페이지 이동

[대기방]
QuizWaitingRoom.jsx (150-200 lines)
├─ useWaitingRoom() - 상태 관리
├─ useWaitingWebSocket() - WebSocket 이벤트
├─ useWaitingJanus() - WebRTC 연결
├─ useRoomExit() - 퇴장 로직
└─ 컴포넌트 조합
    ├─ WaitingRoomHeader
    ├─ WaitingRoomControls
    └─ WaitingParticipantGrid

[게임 페이지]
QuizGamePage.jsx
├─ useQuizGame() - 게임 상태 (기존)
├─ useQuizWebSocket() - WebSocket (기존)
├─ useRoomExit() - 퇴장 로직 (신규)
└─ 게임 전용 정리 로직
    ├─ 녹화 중단
    └─ FastAPI 연결 해제
```

### 4.2 단계별 구현 계획

#### Phase 1: 공통 퇴장 훅 생성
**목표**: 두 페이지에서 공통으로 사용할 퇴장 로직 추상화

**파일**: `frontend/src/hooks/useRoomExit.js`

**기능**:
- Janus WebRTC 연결 정리
- 웹캠 스트림 정지
- WebSocket 연결 해제
- 페이지 이동

**인터페이스**:
```javascript
const { cleanupAndExit } = useRoomExit({
  janusRef,
  pluginHandleRef,
  remoteFeedsRef,
  userIdToFeedIdRef,
  setRemoteStreams,
  setIsJanusConnected,
  stopWebcam,
  isWebcamOn,
  navigateTo: '/main' // 이동할 경로
});
```

#### Phase 2: 대기방 리팩토링
**목표**: QuizWaitingRoom을 QuizGamePage와 동일한 구조로 리팩토링

**2-1. 커스텀 훅 생성**
- `useWaitingRoom.js`: 방 정보, 참가자 상태 관리
- `useWaitingWebSocket.js`: WebSocket 이벤트 처리
- `useWaitingJanus.js`: Janus WebRTC 연결 관리

**2-2. 컴포넌트 분리**
- `WaitingRoomHeader.jsx`: 방 정보 헤더
- `WaitingRoomControls.jsx`: 웹캠/준비 버튼
- `WaitingParticipantCard.jsx`: 참가자 카드
- `WaitingParticipantGrid.jsx`: 참가자 그리드

**2-3. 메인 컴포넌트 리팩토링**
- 기존 로직을 훅으로 이동
- JSX를 컴포넌트로 교체
- useRoomExit 훅 통합



#### Phase 3: 게임 페이지 퇴장 로직 구현
**목표**: QuizGamePage에 완전한 퇴장 로직 추가

**3-1. useRoomExit 훅 통합**
```javascript
const { cleanupAndExit } = useRoomExit({
  janusRef,
  pluginHandleRef,
  remoteFeedsRef,
  userIdToFeedIdRef,
  setRemoteStreams,
  setIsJanusConnected,
  stopWebcam,
  isWebcamOn,
  navigateTo: '/main'
});
```

**3-2. 게임 전용 정리 로직 추가**
```javascript
const handleGameExit = async () => {
  try {
    // 1. 녹화 중단
    if (isRecordingRef.current) {
      isRecordingRef.current = false;
      if (recordingRef.current) {
        cancelAnimationFrame(recordingRef.current);
        recordingRef.current = null;
      }
    }
    
    // 2. FastAPI WebSocket 연결 해제
    quizFastApi.disconnect();
    fastApiConnectedRef.current = false;
    metaSentRef.current = false;
    
    // 3. 공통 퇴장 로직 실행
    await cleanupAndExit();
    
  } catch (error) {
    console.error('❌ 게임 퇴장 실패:', error);
    navigate('/main');
  }
};
```

**3-3. 모달 연결**
```javascript
const handleExit = () => setShowExitModal(true);
const confirmExit = () => handleGameExit();
```

#### Phase 4: 테스트 및 검증
**목표**: 모든 퇴장 시나리오 테스트

**테스트 케이스**:
1. 대기방 일반 참가자 퇴장
2. 대기방 방장 퇴장 (방 종료)
3. 게임 도전 대기 중 퇴장
4. 게임 내 차례 중 퇴장
5. 게임 다른 사람 차례 중 퇴장
6. 게임 종료 후 대기실 복귀
7. 네트워크 끊김 시나리오

### 4.3 핵심 구현 코드

#### useRoomExit.js (공통 퇴장 훅)
```javascript
/**
 * 퀴즈 방 퇴장을 위한 공통 훅
 * 
 * 🔥 중요: 백엔드에는 명시적인 퇴장 API가 없습니다!
 * 이 훅은 단순히 websocketService.disconnect()를 호출하고,
 * 백엔드가 DISCONNECT 이벤트를 감지하여 자동으로 퇴장 처리합니다.
 * 
 * 처리 순서:
 * 1. 게임 전용 리소스 정리 (onBeforeExit)
 * 2. Janus WebRTC 정리
 * 3. 웹캠 정리
 * 4. WebSocket 연결 해제 ⭐ (백엔드가 자동으로 퇴장 처리)
 * 5. 페이지 이동
 */
import { useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import websocketService from '../services/websocket/websocketService';

export const useRoomExit = ({
  janusRef,
  pluginHandleRef,
  remoteFeedsRef,
  userIdToFeedIdRef,
  setRemoteStreams,
  setIsJanusConnected,
  stopWebcam,
  isWebcamOn,
  navigateTo = '/main',
  onBeforeExit = null, // 퇴장 전 추가 작업 (게임 페이지: 녹화 중단, FastAPI 해제)
}) => {
  const navigate = useNavigate();
  
  const cleanupAndExit = useCallback(async () => {
    try {
      console.log('🚪 방 나가기 처리 시작');
      
      // 0. 퇴장 전 추가 작업 실행 (옵션)
      // 게임 페이지: 녹화 중단, FastAPI WebSocket 해제
      if (onBeforeExit) {
        await onBeforeExit();
      }
      
      // 1. Janus WebRTC 정리
      if (janusRef.current) {
        try {
          // Remote feeds 정리
          if (remoteFeedsRef.current) {
            Object.values(remoteFeedsRef.current).forEach(feed => {
              try {
                if (feed && typeof feed.detach === 'function') {
                  feed.detach();
                }
              } catch (error) {
                console.error('Remote feed detach 실패:', error);
              }
            });
            remoteFeedsRef.current = {};
          }
          
          // Publisher 정리
          if (pluginHandleRef.current) {
            try {
              pluginHandleRef.current.detach();
            } catch (error) {
              console.error('Plugin detach 실패:', error);
            }
            pluginHandleRef.current = null;
          }
          
          // Janus 세션 종료
          janusRef.current.destroy();
          janusRef.current = null;
          
          // 상태 초기화
          if (userIdToFeedIdRef.current) {
            userIdToFeedIdRef.current = {};
          }
          setIsJanusConnected(false);
          setRemoteStreams({});
          
          console.log('✅ Janus 정리 완료');
        } catch (error) {
          console.error('❌ Janus 정리 실패:', error);
        }
      }
      
      // 2. 웹캠 정리
      if (isWebcamOn && stopWebcam) {
        try {
          stopWebcam();
          console.log('✅ 웹캠 정리 완료');
        } catch (error) {
          console.error('❌ 웹캠 정리 실패:', error);
        }
      }
      
      // 3. WebSocket 연결 해제
      // ⭐⭐⭐ 핵심: disconnect()만 호출하면 끝!
      // 백엔드가 DISCONNECT 이벤트를 자동 감지하여:
      // - GameRoomLeaveService.leaveCurrentRoomByUser() 자동 실행
      // - 참가자 정보 DB 삭제
      // - 방 참가자 수 감소
      // - 게임 중이면 캐시 정리
      // - 방장이면 방 종료 및 남은 참가자 세션 정리
      // - PARTICIPANT_LEFT 또는 ROOM_CLOSED 이벤트 브로드캐스트
      // 모든 것이 자동으로 처리됩니다!
      try {
        websocketService.disconnect();
        console.log('✅ WebSocket 연결 해제 완료 (백엔드가 자동으로 퇴장 처리)');
      } catch (error) {
        console.error('❌ WebSocket 해제 실패:', error);
      }
      
      // 4. 페이지 이동
      navigate(navigateTo);
      
    } catch (error) {
      console.error('❌ 방 나가기 실패:', error);
      // 실패 시에도 강제 이동
      navigate(navigateTo);
    }
  }, [
    janusRef,
    pluginHandleRef,
    remoteFeedsRef,
    userIdToFeedIdRef,
    setRemoteStreams,
    setIsJanusConnected,
    stopWebcam,
    isWebcamOn,
    navigate,
    navigateTo,
    onBeforeExit,
  ]);
  
  return { cleanupAndExit };
};
```



#### QuizGamePage에서 사용
```javascript
// QuizGamePage.jsx
import { useRoomExit } from '../../hooks/useRoomExit';

const QuizGamePage = () => {
  // ... 기존 코드 ...
  
  // 퇴장 훅 사용
  const { cleanupAndExit } = useRoomExit({
    janusRef,
    pluginHandleRef,
    remoteFeedsRef,
    userIdToFeedIdRef,
    setRemoteStreams,
    setIsJanusConnected,
    stopWebcam,
    isWebcamOn,
    navigateTo: '/main',
    onBeforeExit: async () => {
      // 게임 전용 정리 작업
      console.log('🎮 게임 전용 리소스 정리 시작');
      
      // 1. 녹화 중단
      if (isRecordingRef.current) {
        isRecordingRef.current = false;
        if (recordingRef.current) {
          cancelAnimationFrame(recordingRef.current);
          recordingRef.current = null;
        }
        console.log('✅ 녹화 중단 완료');
      }
      
      // 2. FastAPI WebSocket 연결 해제
      try {
        quizFastApi.disconnect();
        fastApiConnectedRef.current = false;
        metaSentRef.current = false;
        console.log('✅ FastAPI 연결 해제 완료');
      } catch (error) {
        console.error('❌ FastAPI 연결 해제 실패:', error);
      }
    }
  });
  
  // 나가기 버튼 핸들러
  const handleExit = () => setShowExitModal(true);
  const confirmExit = () => cleanupAndExit();
  
  // ... 나머지 코드 ...
};
```

#### QuizWaitingRoom에서 사용 (리팩토링 후)
```javascript
// QuizWaitingRoom.jsx
import { useRoomExit } from '../../hooks/useRoomExit';
import { useWaitingRoom } from '../../hooks/useWaitingRoom';
import { useWaitingWebSocket } from '../../hooks/useWaitingWebSocket';
import { useWaitingJanus } from '../../hooks/useWaitingJanus';

const QuizWaitingRoom = () => {
  const { roomId } = useParams();
  const { user } = useAuthStore();
  const myUserId = user?.userId;
  
  // 상태 관리 훅
  const {
    roomInfo,
    setRoomInfo,
    participants,
    setParticipants,
    allReady,
  } = useWaitingRoom();
  
  // WebSocket 훅
  const { setReady, startGame } = useWaitingWebSocket({
    roomId,
    myUserId,
    onRoomJoin: handleRoomJoin,
    onParticipantEvent: handleParticipantEvent,
    onGameStart: handleGameStart,
    onRoomClosed: handleRoomClosed,
    onError: handleError,
  });
  
  // Janus WebRTC 훅
  useWaitingJanus({
    roomId,
    myUserId,
    participants,
    isWebcamOn,
    stream,
  });
  
  // 퇴장 훅
  const { cleanupAndExit } = useRoomExit({
    janusRef,
    pluginHandleRef,
    remoteFeedsRef,
    userIdToFeedIdRef,
    setRemoteStreams,
    setIsJanusConnected,
    stopWebcam,
    isWebcamOn,
    navigateTo: '/main',
  });
  
  // 나가기 버튼 핸들러
  const handleExit = () => setShowExitModal(true);
  const confirmExit = () => cleanupAndExit();
  
  // ... JSX 렌더링 ...
};
```

---

## 5. 구현 가이드

### 5.1 우선순위

#### 높음 (즉시 구현)
1. **useRoomExit 훅 생성**: 공통 퇴장 로직 추상화
2. **QuizGamePage 퇴장 로직**: 게임 중 나가기 기능 구현

#### 중간 (다음 스프린트)
3. **useWaitingWebSocket 훅**: WebSocket 로직 분리
4. **useWaitingJanus 훅**: Janus 로직 분리
5. **useWaitingRoom 훅**: 상태 관리 분리

#### 낮음 (점진적 개선)
6. **컴포넌트 분리**: UI 모듈화
7. **테스트 코드 작성**: 단위 테스트 및 통합 테스트

### 5.2 구현 순서

#### Step 1: useRoomExit 훅 생성 (1-2시간)
```bash
# 파일 생성
frontend/src/hooks/useRoomExit.js

# 구현 내용
- Janus 정리 로직
- 웹캠 정리 로직
- WebSocket 해제 로직
- onBeforeExit 콜백 지원
```

#### Step 2: QuizGamePage 퇴장 로직 구현 (2-3시간)
```bash
# 수정 파일
frontend/src/pages/quiz/QuizGamePage.jsx

# 구현 내용
- useRoomExit 훅 import
- onBeforeExit에 게임 전용 정리 로직 추가
- confirmExit 함수 수정
- 테스트
```

#### Step 3: QuizWaitingRoom에 useRoomExit 적용 (1시간)
```bash
# 수정 파일
frontend/src/pages/quiz/QuizWaitingRoom.jsx

# 구현 내용
- useRoomExit 훅 import
- cleanupAndExit 함수 교체
- 기존 로직 제거
- 테스트
```



#### Step 4: 대기방 리팩토링 (8-10시간)
```bash
# 새로 생성할 파일들
frontend/src/hooks/useWaitingRoom.js
frontend/src/hooks/useWaitingWebSocket.js
frontend/src/hooks/useWaitingJanus.js
frontend/src/components/quiz/waiting/WaitingRoomHeader.jsx
frontend/src/components/quiz/waiting/WaitingRoomControls.jsx
frontend/src/components/quiz/waiting/WaitingParticipantCard.jsx
frontend/src/components/quiz/waiting/WaitingParticipantGrid.jsx

# 수정 파일
frontend/src/pages/quiz/QuizWaitingRoom.jsx (대폭 축소)
```

### 5.3 테스트 체크리스트

#### 대기방 퇴장 테스트
- [ ] 일반 참가자가 나가기 버튼 클릭
  - [ ] 확인 모달 표시
  - [ ] 확인 시 메인 페이지로 이동
  - [ ] 다른 참가자들에게 퇴장 알림 표시
  - [ ] 참가자 수 감소
  - [ ] 웹캠 스트림 정지
  - [ ] Janus 연결 종료
  - [ ] WebSocket 연결 해제

- [ ] 방장이 나가기 버튼 클릭
  - [ ] 확인 모달 표시
  - [ ] 확인 시 메인 페이지로 이동
  - [ ] 남은 참가자들에게 방 종료 알림 표시
  - [ ] 남은 참가자들 자동으로 메인으로 이동
  - [ ] 방 상태가 CLOSED로 변경

#### 게임 중 퇴장 테스트
- [ ] 도전 대기 중 나가기
  - [ ] 확인 모달 표시
  - [ ] 확인 시 메인 페이지로 이동
  - [ ] 다른 참가자들에게 퇴장 알림
  - [ ] 게임 계속 진행

- [ ] 내 차례 중 나가기
  - [ ] 녹화 중단 확인
  - [ ] FastAPI 연결 해제 확인
  - [ ] 다음 도전자에게 차례 넘어감
  - [ ] 게임 계속 진행

- [ ] 다른 사람 차례 중 나가기
  - [ ] 정상적으로 퇴장
  - [ ] 게임 계속 진행

#### 엣지 케이스 테스트
- [ ] 네트워크 끊김
  - [ ] 백엔드가 자동으로 퇴장 처리
  - [ ] 다른 참가자들에게 알림

- [ ] 브라우저 강제 종료
  - [ ] WebSocket DISCONNECT 이벤트 발생
  - [ ] 백엔드가 자동으로 퇴장 처리

- [ ] 동시 다발적 퇴장
  - [ ] 각 참가자 독립적으로 처리
  - [ ] 방장이 마지막이면 방 종료

### 5.4 주의사항

#### 1. Janus 연결 정리 순서
```javascript
// 올바른 순서
1. Remote feeds detach
2. Plugin handle detach
3. Janus session destroy
4. Refs 초기화
5. State 초기화

// 잘못된 순서 (메모리 누수 발생)
1. Janus session destroy
2. Remote feeds detach (이미 세션이 없어서 실패)
```

#### 2. WebSocket 연결 해제 타이밍
```javascript
// ✅ 올바른 방법 (백엔드가 DISCONNECT 이벤트를 감지하여 자동 퇴장 처리)
websocketService.disconnect();

// ❌ 잘못된 방법 (명시적 퇴장 API가 존재하지 않음!)
websocketService.leaveRoom(roomId);  // 이런 API 없음!
websocketService.sendMessage('/app/room/leave', {}); // 이런 엔드포인트 없음!

// ❌ 불필요한 방법 (disconnect만으로 충분)
websocketService.sendMessage('/app/room/exit', {});
websocketService.disconnect();
```

**중요**: 백엔드는 WebSocket DISCONNECT 이벤트만으로 모든 퇴장 처리를 자동으로 수행합니다.
클라이언트는 단순히 `disconnect()`만 호출하면 됩니다.

#### 3. 게임 중 퇴장 시 추가 정리
```javascript
// 반드시 정리해야 할 것들
1. isRecordingRef.current = false
2. cancelAnimationFrame(recordingRef.current)
3. quizFastApi.disconnect()
4. fastApiConnectedRef.current = false
5. metaSentRef.current = false
```

#### 4. 에러 처리
```javascript
// 각 정리 단계를 try-catch로 감싸기
try {
  // Janus 정리
} catch (error) {
  console.error('Janus 정리 실패:', error);
  // 계속 진행 (다음 정리 단계 실행)
}

// 최종적으로 실패해도 페이지 이동
finally {
  navigate('/main');
}
```

### 5.5 성능 최적화

#### 1. useCallback 사용
```javascript
// 퇴장 함수는 useCallback으로 메모이제이션
const cleanupAndExit = useCallback(async () => {
  // ...
}, [dependencies]);
```

#### 2. 비동기 처리
```javascript
// Janus leave 요청은 Promise로 처리
await new Promise((resolve) => {
  pluginHandleRef.current.send({ 
    message: { request: 'leave' },
    success: resolve,
    error: resolve
  });
  setTimeout(resolve, 500); // 타임아웃
});
```

#### 3. 병렬 처리 가능한 작업
```javascript
// 독립적인 작업은 병렬로 실행
await Promise.all([
  cleanupJanus(),
  cleanupWebcam(),
  cleanupFastApi()
]);
```

---

## 6. 예상 효과

### 6.1 코드 품질 개선
- **가독성 향상**: 600줄 → 150-200줄
- **유지보수성 향상**: 로직 분리로 수정 용이
- **재사용성 향상**: 공통 훅으로 코드 재사용
- **테스트 용이성**: 각 훅을 독립적으로 테스트 가능

### 6.2 사용자 경험 개선
- **안정성 향상**: 리소스 누수 방지
- **응답성 향상**: 빠른 페이지 전환
- **일관성 향상**: 모든 페이지에서 동일한 퇴장 경험

### 6.3 개발 생산성 향상
- **신규 기능 추가 용이**: 훅 기반 구조로 확장 쉬움
- **버그 수정 용이**: 로직 분리로 디버깅 쉬움
- **코드 리뷰 용이**: 작은 단위로 리뷰 가능

---

## 7. 결론

### 핵심 요약
1. **공통 퇴장 훅 생성**: useRoomExit으로 중복 코드 제거
2. **게임 페이지 퇴장 구현**: 완전한 리소스 정리 로직 추가
3. **대기방 리팩토링**: 훅과 컴포넌트 분리로 구조 개선

### 🔥 가장 중요한 포인트
**백엔드에는 명시적인 퇴장 API가 없습니다!**

프론트엔드는 단순히 `websocketService.disconnect()`만 호출하면:
- 백엔드가 DISCONNECT 이벤트를 자동 감지
- GameRoomLeaveService가 자동으로 퇴장 처리
- 참가자 정보 삭제, 방 인원 감소, 캐시 정리
- 방장이면 방 종료 및 남은 참가자 세션 정리
- 다른 참가자들에게 자동으로 알림 전송

**모든 것이 자동으로 처리됩니다!**

따라서 프론트엔드 구현 시:
```javascript
// ✅ 올바른 구현
const cleanupAndExit = async () => {
  // 1. Janus 정리
  // 2. 웹캠 정리
  // 3. websocketService.disconnect() ⭐ 이것만!
  // 4. 페이지 이동
};

// ❌ 잘못된 구현 (불필요한 API 호출)
const cleanupAndExit = async () => {
  await websocketService.leaveRoom(roomId); // 이런 API 없음!
  websocketService.disconnect();
};
```

### 우선순위
1. **즉시**: useRoomExit 훅 + QuizGamePage 퇴장 로직
2. **다음**: 대기방 WebSocket/Janus 훅 분리
3. **점진적**: 컴포넌트 분리 및 테스트 코드

### 예상 작업 시간
- **Phase 1 (긴급)**: 3-5시간
- **Phase 2-3 (중요)**: 10-15시간
- **Phase 4 (개선)**: 5-8시간
- **총합**: 18-28시간 (2-3일)
